\section{Multigrid solver}
\label{sec:da_solver}

In this section a multigrid solver for the diffusion approximation is developed. Multigrid schemes are the most efficient iterative methods for solving diffusion-type equations. The core idea is to propagate the error on a coarse grid during each iteration and take that propagated error into account when doing an iteration step on the original high resolution grid. Particularly useful is the fact that the multigrid method can be employed on any system of linear equations as long as a so called restriction and interpolation operator is being provided. 

The automatic discretization machinery which was developed as part of the $P_N$-solver in section~\ref{sec:pn_solver} takes arbitrary systems of potentially coupled, linear partial differencial equations as input. The diffusion equation which has been derived in the previous section is a linear scalar partial differencial equation and therefore can be fed into the $P_N$-solver from section~\ref{sec:pn_solver} to produce valid stencil code (independent of mesh resolution).

The idea behind the multigrid method is to accelerate the convergence by using a coarse grid on which information propagates much faster throughout the spatial domain. The coarse solution is then used for updating the original grid with finer resolution in each iteration.
\begin{figure}[h]
\centering
\missingfigure{multigrid mesh setup}
\caption{Some caption}
\label{fig:da_solver_multigrid_mesh}
\end{figure}

Quantities on the original fine mesh are denoted with the subscript $F$. We therefore have for the original system of equations:
\begin{align}
\nonumber
A_F\vec{u}_F = \vec{b}_F
\end{align}
The multigrid method is an iterative method. This is expressed with a superscript index which denotes the multigrid iteration. The first step in the multigrid cycle is to partially converge the solution by applying a number of iterations of an iterative method, such as Conjugate-Gradient or Gauss-Seidel. The partially converged solution Ã­n the first multigrid cycle is denoted $\vec{u}_F^0$. Then the residual is computed on the fine mesh:
\begin{align}
\nonumber
\vec{r}_F^0 = \vec{b}_F-A_F\vec{u}_F^0
\end{align}
The idea behind multigrid is to use the coarse grid to smooth out the error and use the result as a correction for the next iterations on the fine mesh. To facilitate this, the residual on the fine mesh is first transferred onto the coarse mesh. This is done by downsampling the fine mesh residual (often also called interpolation). This operation can be represented as a non-symmetric matrix $M$. Quantities on the coarse mesh are denoted with the subscript $C$:
\begin{align}
\nonumber
\vec{r}_C^0 = M_{F\rightarrow C} \vec{r}_F^0
\end{align}
After bringing the residual onto the coarse mesh, the next step is to solve the correction equation to full convergence. The correction equation is derived by looking at the system on the coarse mesh using the partially converged solution:
\begin{align}
\nonumber
A_C\vec{u}_C^0 = \vec{b}_C
\end{align}
Rearranging this equation allows us to use the downsampled residual as the right hand side vector:
\begin{align}
\nonumber
\vec{b}_C - A_C\vec{u}_C^0 = \vec{r}_C^0
\end{align}
We substitute $\vec{b}_C$ with $A_C\vec{u}_C=\vec{b}_C$ (using the fully converged yet unknown solution on the coarse grid $\vec{u}_C$) and get:
\begin{align}
A_C\vec{u}_C - A_C\vec{u}_C^0 &= \vec{r}_C^0
\nonumber
\\
A_C\left(\vec{u}_C-\vec{u}_C^0\right) &= \vec{r}_C^0
\nonumber
\\
A_C\vec{e}_C^0 &= \vec{r}_C^0
\label{eq:da_correction_equation}
\end{align}
The quantity $\vec{e}_C^0$ is the unknown error between the final solution $\vec{u}_C$ and its partially converged approximation $\vec{u}_C^0$. Equation~\ref{eq:da_correction_equation} is called the correction equation and is solved to full convergence. The computed error is upsampled onto the finer grid using the upsampling operator $M_{C\rightarrow F}$:
\begin{align}
\vec{e}_F^0 = M_{C\rightarrow F}\vec{e}_C^0
\nonumber
\end{align}
Using the upsampled error we can apply a correction step to the solution on the fine grid:
\begin{align}
\vec{e}_F^0 &= \vec{u}_F - \vec{u}_F^0
\nonumber
\\
\vec{u}_F &=  \vec{e}_F^0 + \vec{u}_F^0
\nonumber
\\
\vec{u}_F^1  &\leftarrow \vec{u}_F
\nonumber
\end{align}
This process is then repeated starting with the corrected approximation $\vec{u}_F^1$. In summary the multigrid steps are:
\begin{enumerate}
\item Solve the original system on the fine grid using a small number of iteration steps to bring the solution $\vec{u}_F^0$ to partial convergence.
\item Compute the residual $\vec{r}_F^0=\vec{b}_F - A_F\vec{u}_F^0$ on the fine grid and transfer it onto the coarse grid $\vec{r}_C^0 = M_{F\rightarrow C}\vec{r}_F^0$.
\item Solve the correction equation $A_C\vec{e}_C^0 = \vec{r}_C^0$ for $\vec{e}_C^0$ to full convergence on the coarse grid.
\item Transfer the result to the fine grid $\vec{e}_F^0 = M_{C\rightarrow F}\vec{e}_C^0$.
\item Use $\vec{e}_F^0$ to apply the correction $\vec{u}_F^1 =  \vec{e}_F^0 + \vec{u}_F^0$.
\end{enumerate}
What has been outlined here is a two-level multigrid step which could be extended to more levels by applying the same idea recursively to the coarse mesh solve. This is often done so that the linear system of the coarsest level is so small that a direct method for solving it can be applied very efficiently. This generates the V-cycles shown in figure~\ref{fig:da_solver_multigrid_vcycles} for which are characteristic for the multigrid method.
\begin{figure}[h]
\centering
\missingfigure{multigrid v-cycle}
\caption{Some caption}
\label{fig:da_solver_multigrid_vcycles}
\end{figure}


\TD{explain how M is built}




\TD{point out that the automatic discretization can be used}
