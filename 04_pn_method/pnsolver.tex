\section{$P_N$-Solver with Automated Stencil Generation}
\label{sec:pn_solver}

In this section, a new method for solving the $P_N$-equations is being given. This method is based on the idea to automatically generate the linear system of equations directly from a computer algeba representation of the $P_N$-equations. This section will go through the manual steps required to build such a system from general partial differential equations, followed by the motivation for the automated approach taken in this thesis. In subsections~\ref{sec:pn_car} to~\ref{sec:pn_staggered}, the solver and the automation of the individual system-building steps are explained in detail, including the developed software framework and important numerical aspects, such as handling boundary conditions and staggered grids.

There are three reasons why the solver has been designed around the idea of automatic system building. The first reason is that the number of equations for the system depends on the user parameter $N$ (the spherical harmonics truncation order) and is therefore not known in advance during solver implementation. Secondly, the number of equations increases quadratically with truncation order $N$, which makes building the system increasingly laborious, time consuming and prone to errors, if done manually.

The third reason is that there exists a variety of variations of the $P_N$-method in other fields, which deal with different aspects of $P_N$-theory, such as reduction of ringing artefacts and improvement of convergence. Such variations include Simplified-$P_N$ ($SP_N$)~\cite{Ryan10}, Filtered-$P_N$ ($FP_N$)~\cite{Radice13}, Diffusion-Correction-$P_N$ ($DP_N$)~\cite{Schaefer11} and Least-Squares-$P_N$ ($LSP_N$)~\cite{Hansen14}. Common to all these variations is that they reduce to a set of coupled partial differential equations. The idea behind the design of the solver in this thesis is to be able to generate the coefficient matrix and right hand side vector directly from the specification of such a coupled system of equations. This would allow easy implementation and cross-comparisons of these alternate theories from the literature.

The $P_N$-equations have been derived in previous sections by discretizing the continuous angular variable in the radiative transfer equation. This led to a discrete set of coupled partial differential equations, which still depend on the continuous spatial variable~$\vec{x}$. Therefore, the next step is to discretize this spatial variable on a particular domain with input fields for the various radiative quantities, such as extinction or the phase function. Finally, using this discretization, a system of linear equations can be build by assembling a coefficient matrix $A$ and a right hand side vector~$\vec{b}$.

Followingly, the steps for building a linear system from a given partial difference equation will be summarized (using the two-dimensional laplace equation as example). The next subsections then will revisit each step and elaborate on how it has been automated as part of the solver.

\subsubsection*{Spatial Discretization}

As mentioned in section~\ref{sec:foundations_deterministic}, a discrete representation of the geometry that covers the problem domain is required in order to discretize the spatial variable. Throughout this thesis, a regular cartesian grid is used, which will be referred to as finite difference grid. This type of grid is simple and commonly used in graphics. In future it might be worth exploring other complex meshes, such as tetrahedral irregular grids, which are often used in the finite element analysis. 

The finite difference grid defines the locations at which radiative transfer quantities and the solution will be specified. It is parameterized by a worldspace bounding box and a resolution $res=(I,J,K)$ or gridspacing $h=(h_x, h_y, h_z)$ in each dimension. The local space of the grid is referred to as voxelspace.

Using finite difference grids, the discretization consists of replacing quantities, which depend on the continuous variable~$\vec{x}$ with its discrete counterpart $x_{ijk}$, where $ijk$ is a coordinate in voxelspace. This coordinate is still continuous and $x_{i+\frac{1}{2}jk}$ is a valid coordinate. Quantities around grid point locations are found by interpolation. Troughout this thesis a trilinear interpolation for three-dimensional grids and bilinear interpolation for two-dimensional grids will be used. Higher order interpolation would be possible and an avenue for future exploration.
\begin{figure}[h]
\centering
%\missingfigure{image of finite difference grid showing domain, and gridpoints and indices and voxelsize h, and interpolation}
\includegraphics[width=0.6\textwidth]{04_pn_method/figures/fig_fd_grids.pdf}
\caption{Image of finite difference grid showing domain (white cells), boundary (gray cells), gridpoints (red), voxelsize $h$ and interpolation.}
\label{fig:pn_solver_finite_difference_grid}
\end{figure}

The first step during a discretization is the replacement of $\vec{x}\rightarrow x_{ijk}$. Using the two-dimensional laplace equation $\nabla^2\phi(\vec{x})=q(\vec{x})$ as an example, this results in:
\begin{align*}
\nabla^2\phi\left(\vec{x}\right)=q\left(\vec{x}\right)
\xrightarrow{\makebox[1cm]{}}
\partial_x^2\phi_{ij}+
\partial_y^2\phi_{ij}
=
q_{ij}
\end{align*}
For notational convenience $\phi_{ijk} = \phi\left(x_{ijk}\right)$ is defined. The spatial derivatives are approximated using central differences:
\begin{align}
\partial_x\phi_{ijk} = \frac{\phi_{i+\frac{1}{2}jk} - \phi_{i-\frac{1}{2}jk}}{h_x}
\label{eq:pn_solver_central_difference}
\end{align}
Continuing with the Laplace example, the substitutions of spatial derivatives are carried out next. Nested derivatives affect the indices accordingly:
\begin{align*}
&
\xrightarrow{\makebox[1cm]{}}
\left(
\frac
{
\partial_x
\phi_{i+\frac{1}{2}j}
-
\partial_x
\phi_{i-\frac{1}{2}j}
}
{h_x}
\right)
-
\left(
\frac
{
\partial_y
\phi_{ij+\frac{1}{2}}
-
\partial_y
\phi_{ij-\frac{1}{2}}
}
{h_y}
\right)
=
q_{ij}
\\
&
\xrightarrow{\makebox[1cm]{}}
\frac
{
\frac{\phi_{i+1j} - \phi_{ij}}{h_x}
-
\frac{\phi_{ij} - \phi_{i-1j}}{h_x}
}
{h_x}
-
\frac
{
\frac{\phi_{ij+1} - \phi_{ij}}{h_y}
-
\frac{\phi_{ij} - \phi_{ij-1}}{h_y}
}
{h_y}
=
q_{ij}
\end{align*}

\subsubsection*{Canonical Form}
After application of the discretization, the resulting equation is brought into canonical form, which means that the expression is factorized according to the unknowns $\phi_{ij}$:
\begin{align}
\xrightarrow{\makebox[1cm]{}}
\frac{1}{h_x^2}\phi_{i+1j}
+\frac{1}{h_x^2}\phi_{i-1j}
+\frac{1}{h_y^2}\phi_{ij+1}
+\frac{1}{h_y^2}\phi_{ij-1}
-2\left(\frac{1}{h_x^2}+\frac{1}{h_y^2}\right)\phi_{ij}
=
q_{ij}
\label{eq:pn_laplace_canonical_form}
\end{align}

\subsubsection*{Stencil Code Crafting}

Consequently, the canonical form is used to derive the stencil code. This is done by interpreting the equation as a product between a row in the coefficient matrix $A$ and the vector of unknowns (the solution vector $\vec{u}$), resulting in the right hand side $q_{ij}$. The regular structure of the discretization reveals a pattern, which is the same for every row and is called a stencil code.

\begin{figure}[h]
\centering
\includegraphics[width=0.6\textwidth]{04_pn_method/figures/fig_code_stencil.pdf}
%\missingfigure{source code figure for simple stencil code}
\caption{Spatial discretization of partial differential equations will lead to stencil code which is executed to populate the system matrix $A$ and right hand side vector $b$.}
\label{fig:pn_solver_stencil_code}
\end{figure}

The purpose of the stencil code is to be executed repeatedly in order to populate the system matrix $A$ and right hand side $\vec{b}$. This requires a mapping of multi-dimensional indices $ijk$ to linear indices into rows of $\vec{u}$ (and columns of $A$). This mapping is referred to as \emph{index} function. The components of the solution vector $\vec{u}$ are associated with unknowns at specific grid locations $ijk$. In case of the Laplace example this would be written as:
\begin{align}
u_{\operatorname{index}\left(ijk\right)} = \phi_{ijk}\quad\text{ with }\quad \operatorname{index}: \mathbb{Z}^3\mapsto\mathbb{Z}
\label{eq:pn_index_mapping}
\end{align}

Also functions for accessing discretized input fields (such as $q$ in the Laplace example) and parameters, such as the voxelsize $h$, will be called by the stencil code to retrieve required values.

\subsubsection*{System Matrix Population and Solve}
The stencil code is compiled and executed for each row in $A$ to populate the system. Depending on the matrix-properties of $A$, different standard methods for solving the linear system $A\vec{u}=\vec{b}$ can be applied to find the solution $\vec{u}$, the discretized radiance field. This solution can then be used in a rendering application.
\begin{figure}[h]
\centering
%\missingfigure{image overview of the numerical pipeline}
\includegraphics[width=1.0\textwidth]{04_pn_method/figures/fig_pipeline.pdf}
\caption{Overview of the method for solving the $P_N$-equations which is introduced in this chapter. The core idea is to automate the stencil code generation using a computer algebra representation of the equations.}
\label{fig:pn_solver_stencil_overview}
\end{figure}

In the following subsections, the new solver will be introduced as as a general framwork for automization of the steps for system building. The first subsection discusses how a computer algebra representation is used to represent the equation to be solved. Subsection~\ref{sec:pn_stencil_gen} shows how the spatial discretization and stencil code generation are modeled as operations on that representation. Subsection~\ref{sec:pn_bc} explains the aspects of the system which are related to boundary conditions, followed by subsection~\ref{sec:pn_framework} which discusses the surrounding framework and how the generated stencil is used within that framework. Subsection~\ref{sec:pn_staggered} elaborates on the extension of the solver to staggered grids, which is necessary for the solver to produce useful results. Finally, subsection~\ref{sec:pn_system_matrix} is dedicated to properties of the coefficient matrix $A$ and methods for solving the linear system.

\subsection{Computer Algebra Representation}
\label{sec:pn_car}

At the core of the solver is a computer algebra representation of the equations, which the system is trying to solve on a given domain. This representation is a mathematical expression tree (Preiss~\cite{Preiss00}). Each node within that tree can have any number of children and represents a constant, mathematical symbol or a mathematical operation, such as integration, derivation, power, addition or multiplication. Representations of complex equations are constructed by nesting nodes into a larger tree, where child nodes are considered arguments of the operation, represented by the parent node.

A number of computer algebra systems exist, such as SymPy~\cite{Meurer17}, which allow to generate and manipulate computer algebra representations. However, for this thesis a small lightweight computer algebra representation containing the required subset has been developed. Figure~\ref{fig:pn_math_expression_tree_generation} demonstrates how this system is used to build the expression trees for the examples above.
\begin{figure}[h]
\centering
%\missingfigure{code listing showing how the expression tree is build}
\includegraphics[width=1.0\textwidth]{04_pn_method/figures/fig_car_representation2.pdf}
\caption{An Python-API is used to create the expression tree representation for mathematical expressions.}
\label{fig:pn_math_expression_tree_generation}
\end{figure}

Manipulations of mathematical expressions, such as expansions, the application of identities, substitution, factorization or rearranging of terms can be expressed as operations on the expression tree (see figure~\ref{fig:pn_math_expression_tree_manipulation}). Section~\ref{sec:pn_stencil_gen} will assess how the spatial discretization is carried out as such an operation.
\begin{figure}[h]
\centering
%\missingfigure{image of representing binomial expansion as operation on expression tree}
\includegraphics[width=0.7\textwidth]{04_pn_method/figures/fig_car_expansion.pdf}
\caption{Algebraic manipulations of equations are expressed as operations on the expression tree given by the computer algebra representation.}
\label{fig:pn_math_expression_tree_manipulation}
\end{figure}

\subsection{Discretization}
\label{sec:pn_stencil_gen}

After expressing the $P_N$-equations in the computer algebra representation, the spatial discretization is carried out as a manipulation step on the mathematical expression tree. This is done by by parsing the tree from the root. The equation is supposed to be discretized at position $\vec{x}$, which initially coincides with the location $x_{ijk}$ in the discretized domain. This location is kept on a stack by the parser.

When a differential operator is encountered during tree parsing, the subtree representing the expression to be derived is instantiated twice according to the finite difference expression in equation~\ref{eq:pn_solver_central_difference} with appropriate weighting factors. The current position on the stack is adjusted and pushed on the stack again, when decending down in the tree on each side of the central difference expression. This will produce higher order stencils for nested differential operators.
\begin{figure}[h]
\centering
%\missingfigure{image showing math expression tree for how the differential operator is being replaced with central difference. also mark the position on the stack.}
\includegraphics[width=1.0\textwidth]{04_pn_method/figures/fig_car_discretization.pdf}
\caption{Discretization is carried out as an operation on the expression tree where partial derivatives are replaced by finite difference subtrees. Continous variables are replaced by discrete counterparts, for which offsets are retrieved from a stack which is maintained during tree parsing.}
\label{fig:pn_discretization_differential}
\end{figure}

Once the parser arrives at the symbol $\vec{x}$ in the tree, it is replaced by its discrete counterpart. The top of the discrete position stack indicates where the unknown is expected to be evaluated relative to position $ijk$, at which the whole equation is being evaluated. If the position on top of the stack is the same, then the unknown at $ijk$ is used to replace $\vec{x}$ in the expression. If the unknown is expected to be evaluated at a different location than $ijk$ (due to central differences), then $\vec{x}$ is being substituted by an expression which expresses the interpolation of the unknowns from the gridpoints at which they are defined for the position on top of the stack (figure~\ref{fig:pn_discretization_interpolation}). This ensures, that the final expression only contains unknowns, for which an element in the solution vector exists. This will automatically handle the introduction of staggered grids later in section~\ref{sec:pn_staggered}.
\begin{figure}[h]
\centering
%\missingfigure{image showing interpolation.}
\includegraphics[width=0.7\textwidth]{04_pn_method/figures/fig_car_interpolation.pdf}
\caption{Continuous field variables are turned into discrete counterparts by replacing them with an expression subtree which realizes an interpolation.}
\label{fig:pn_discretization_interpolation}
\end{figure}

After applying the discretization to the expression tree, the equation is being factorized according to the unknowns ($\phi$ in the Laplace example). The factorization is applied as a sequence of manipulation operations to the expression tree, including application of the distributive law. A seperate step iterates over all resulting terms and merges coefficients from multiple instances of the same unknown, so that each unknown appears only once (canonical form).

\subsection{Stencil Code Generation}
\label{sec:pn_stencil_gen2}

The expression tree of the canoncial form is analyzed and rendered into stencil code. This is facilitated by different rendering frontends which allow rendering the expression tree to latex or C++-code (see figure~\ref{fig:pn_math_expression_tree_rendering}).
\begin{figure}[h]
\centering
%\missingfigure{image showing rendering frontends for source code and latex}
\includegraphics[width=1.0\textwidth]{04_pn_method/figures/fig_car_rendering.pdf}
\caption{Rendering frontends allow turning expression trees into source code.}
\label{fig:pn_math_expression_tree_rendering}
\end{figure}

If a term contains an unknown, then its factor expression subtree is rendered into a source code string. The symbols for voxelsize and other radiative quantities are replaced by function calls into an API, which is being provided by the framework. Finally, the voxelspace coordinate associated with the unknown is used to find a discrete index into the finite difference grid, relative to the original coordinate $ijk$, at which the equation is being evaluated. This discrete index is being used to compute the column in $A$. Hence the assignment expression in the stencil code can be put together.
\begin{figure}[h]
\centering
%\missingfigure{image showing code generation from expression tree in canonical form.}
\includegraphics[width=0.6\textwidth]{04_pn_method/figures/fig_car_canonical_to_code.pdf}
\caption{The discretized equation in canonical form allows straightforward generation of stencil code from the different parts of the expression tree.}
\label{fig:pn_discretization_codegen}
\end{figure}

If the term does not contain an unknown, the whole term is rendered into a single expression, which is being assigned to the current row of the right hand side vector $\vec{b}$.

The stencil code is generated with the assumption of certain function calls being available. These are integrated into a single API which is being provided by the solver framework (figure~\ref{fig:pn_discretization_codegen_stencilAPI}). This API allows the stencil to query the current row in the system for which it is being executed, the voxelsize as well as functions for accessing discrete radiative transfer properties.
\begin{figure}[h]
\centering
\includegraphics[width=0.95\textwidth]{04_pn_method/figures/fig_stencil_api.pdf}
%\missingfigure{image showing the stencil API}
\caption{Stencil code generation assumes an API for querying voxel fields of radiative quantities and accessing entries in coefficient matrix $A$ and right hand side $b$}
\label{fig:pn_discretization_codegen_stencilAPI}
\end{figure}


\subsection{Boundary Conditions}
\label{sec:pn_bc}

Central difference discretization will introduce references to spherical harmonics coefficients, which live outside the computational domain. Those references will be part of the stencil code, which has been generated without the notion of boundaries and boundary conditions and are handled transparently by the solver framework.

Boundary conditions define how the problem behaves directly on the boundary interface of the domain, and are an important aspect of establishing the system of linear equations. Boundary conditions can be effortless specified through the Dirichlet boundary conditions and Neumann boundary conditions, which are both supported by the system introduced in this chapter.

If $D\in\mathbb{R}^3$ defines the volume of the computational domain across which to find a solution to a partial differential equation, then $\partial D\in\mathbb{R}^3$ can be the set of points, which lie directly on the boundary of that domain. With Dirichlet boundary conditions, the value of the unknown is specified at the interface $\partial D$ directly. With Neumann boundary conditions, the behaviour of the solution at the boundary is specified by giving a normal derivative of the solution. Using the Laplace example, this would be:
\begin{align*}
\text{PDE:\ \ } & \nabla^2\phi\left(\vec{x}\right) = q\left(\vec{x}\right)
&
\\
\\
\text{Dirichlet BC:\ \ } & \phi\left(\vec{x}\right) = f\left(\vec{x}\right)
&\forall \vec{x}\in\partial D
\\
\\
\text{Neumann BC:\ \ } & \frac{\partial\phi\left(\vec{x}\right)}{\partial\vec{n}} = g\left(\vec{x}\right)
&\forall \vec{x}\in\partial D
\end{align*}
In most applications for computer graphics, a value of zero for either Dirichlet or Neumann boundaries is adequate and is handled by the system through index bending. Considering the first term of the discretized Laplace equation in equation~\ref{eq:pn_laplace_canonical_form}, the result is the following assignment within the stencil code:
\TD{stencil code for that particular thing}
\begin{align}
A[index(i,j), index(i+1, j)] = 1.0/(h_x*h_x);
\end{align}
The function call $index(i+1, j)$ will not be able to produce a valid column index into the coefficient matrix $A$ for voxels adjacent to the boundary, because the unknown $\phi$ has no discrete element in the solution vector voxels outside the domain. If the value of $\phi$ on the boundary is zero, then the unknown on the boundary voxel would be zero and its coefficient would not matter. Therefore, the simplest solution is to ignore the coefficient and not write anything into the matrix $A$.

In the solver framework, this is implemented by overloading the assignment operator. If the target coefficient of the assignment belongs to a boundary voxel and Dirichlet boundary conditions are enabled, then the assignment is simply ignored and no change to the system matrix $A$ is done.

\begin{figure}[h]
\centering
%\missingfigure{image: boundary voxels and dirichlet boundary condition. location of the boundary interface.maybe an arrow indicating the access of the stencil.show assignment and arrow to boundary voxel coefficient. then arrow to nil.also visualize the boundary surface.}
\includegraphics[width=0.8\textwidth]{04_pn_method/figures/fig_bc_dirichlet.pdf}
\caption{Dirichlet boundary conditions with zero value are modelled by ignoring coefficient assignments to boundary voxels.}
\label{fig:pn_bc_dirichlet}
\end{figure}

With Neumann boundary conditions, the derivative is specified at the boundary. Since the derivative is found using central differences between two adjacent voxels, the boundary condition is controlled by how the coefficient at the voxel near the boundary relates to its adjacent coefficient at the boundary voxel. In the simplest case, the derivative is set to zero, in which the boundary voxel coefficient needs to be identical with its adjacent voxel inside
\begin{align*}
\partial\phi=0\quad\forall\phi\in\partial D
\implies
\frac{\phi_{i+1,j}-\phi_{i,j}}{h_x} = 0
\implies
\phi_{i+1,j}=\phi_{i,j}
\ .
\end{align*}
In the case of adjacent coefficients being equal across the boundary interface, a coefficient $b$ assigned to the boundary $\phi_{i+1,j}$ can be assigned to the adjacent unknown inside the domain resulting in:
\begin{align}
a\phi_{i,j} + b\phi_{i+1,j} = \left(a+b\right)\phi_{i,j}
\quad \text{with}\quad \phi_{i+1,j}=\phi_{i,j}
\end{align}

In the solver framework, this is implemented by index bending. If the target coefficient of the assignment belongs to a boundary voxel and Neumann boundary conditions are enabled, then the index function returns the index of the adjacent voxel inside the domain.

\begin{figure}[h]
\centering
%\missingfigure{image showing neumann boundary conditions and index bending. also visualize the boundary surface.}
\includegraphics[width=0.8\textwidth]{04_pn_method/figures/fig_bc_neumann.pdf}
\caption{Neumann boundary conditions with zero value are modelled by bending indices towards the adjacent inner voxel when assigning coefficients.}
\label{fig:pn_bc_neumann}
\end{figure}

Note how the choice and implementation of the boundary condition has an effect on where the effective boundary interface of the domain is located. With Dirichlet boundary conditions, the interface is directly located at the voxel centers of boundary voxels, while with Neumann boundary conditions, the interface is located at directly between the boundary voxels and inner voxels (figure~\ref{fig:pn_bc_dirichlet} and figure~\ref{fig:pn_bc_neumann}).

\subsection{Solver Framework}
\label{sec:pn_framework}

The stencil code is the result of the automated discretization step, which is carried out on the computer algebra representation and rendered into source code. The resulting stencil code is compiled and linked with a solver framework, which runs it to propagate the system matrix $A$ and right hand side vector $\vec{b}$. By rendering the tree to a different representation and assuming a different API used by the stencil code, different solver frameworks can be supported.
Therefore, the details about the surrounding framework are not relevant for the method in this thesis. In this section however, an outline of the framework, which was implemented as part of this thesis will be given.
\begin{figure}[h]
\centering
%\missingfigure{class diagram of solver framework, including stencil, stencil api, voxelmanager, fields and pnsystem}
\includegraphics[width=0.95\textwidth]{04_pn_method/figures/fig_pn_solver_architecture.pdf}
\caption{High level overview over the $P_N$-solver architecture.}
\label{fig:pn_classes}
\end{figure}

The \emph{Stencil} class is the key structure around which the system is designed, and which serves as a wrapper around the generated stencil code. It specifies the dimension (two- or threedimensional) and the truncation order $N$, as these parameters are being decided during stencil code generation. The \emph{Stencil} class also indirectly specifies the number of spherical harmonics coefficients per voxel. It further specifies the placement of each spherical harmonics coefficient within the voxel. This will become important, when staggered grids are introduced. The stencil specifies the highest order of any derivative operator, which was found during discretization. This will have an effect on the number of layers of boundary voxels around the computational domain. Finally, the \emph{Stencil} class has an apply function, which takes the reference to a \emph{StencilAPI} object as an input and runs the generated stencil code that uses that API to propagate the system matrix $A$ and right hand side vector $\vec{b}$.

The \emph{StencilAPI} class serves as the single interface between the generated stencil code and the surrounding parts of the framework. Figure~\ref{fig:pn_discretization_codegen_stencilAPI} gives an overview over the different query functions offered by the API. Essential are functions for mapping between coordinate spaces, such as worldspace, voxelspace, discrete grid coordinates $ijk$ and linear indices into the solution vector. Essential are functions for querying radiative transfer quantities, such as extinction coefficient or phase function spherical harmonics coefficients at world space positions. Both groups of functions will make use of a reference to a \emph{VoxelManager} and a \emph{Scene} class respectively.

The \emph{Scene} class contains all inputs required to specify the problem to be solved. A \emph{Domain} object describes the extend of the computational domain in worldspace, as well as the resolution of the finite difference grid. Further attached are references to abstract \emph{Field} interfaces, which allow querying scalar or vector fields at arbitrary worldspace positions for extinction coefficient, albedo and the spherical harmonics coefficients of phase function and emission field. This is the place where the problem description is provided as input to the system. Different implementations of these abstract interfaces can be used, such as \emph{Constant} fields or \emph{VoxelGrid} fields. This follows the idea of resolution independent volumes introduced by Tessendorf et al.~\cite{Tessendorf11} and will be referred to for more details.

The resolution of the finite difference grid provided by the \emph{Domain} class and the number of spherical harmonics coefficients by the \emph{Stencil} class, impose the layout of the voxelgrid on the system. The \emph{Stencil} class gives the highest order of the derivation operator found during discretization, and with that drives the number of layers of boundary voxels. The final system of linear equations has to be a single column solution vector with a coefficient matrix of compatible dimensions. Since the computational domain is discretized, using grid coordinates $ijk$, a mapping from three-dimensional coordinates $ijk$ and spherical harmonics coefficient index $c$ to a linear global index needs to be provided. This task becomes more involved, when staggered grids are introduced. This bookkeeping of interior and boundary voxels and their containing spherical harmonics coefficients is performed by the \emph{VoxelManager} class. This class is being initialized with the information about the grid resolution by the \emph{Domain}, number of boundary voxel layers, number of coefficients and the position of each coefficient on the grid by the \emph{Stencil} class. It manages the memory and mapping from multidimensional grid indices to linear indices within the global system.

Finally, the \emph{PNSystemBuilder} class is the structure, which brings the different parts together. It is initialized wit the \emph{Scene} class and the \emph{Stencil} class. Both are provided by the client code and are used during initialization to set up the \emph{VoxelManager}, which provides the layout and setup for the solution vector $\vec{u}$, right hand side vector $\vec{b}$ and system matrix $A$. The purpose of the \emph{PNSystemBuilder} class is to build the system matrix $A$ and right hand side vector $\vec{b}$ and return both to client code. This is done by calling the \emph{build} function on the object.

The \emph{build} function iterates over all voxels. For each voxel, the \emph{StencilAPI} object is set up with the correct indices and data pointers and passed as an argument to a call of the \emph{apply} function of the \emph{Stencil} class. As explained in section~\ref{sec:pn_stencil_gen}, the stencil code will make appropriate calls to the \emph{StencilAPI} object, which will propagate the system matrix $A$ and right hand side vector $\vec{b}$ with the correct values for the row, corresponding to the current voxel in the cycle of the \emph{build} function. The system is fully propagated after the stencil has been executed for every voxel. Separate functions of the \emph{PNSystemBuilder} class allow querying the system martix $A$ and right hand side vector $\vec{b}$ after those have been build.

\subsection{Staggered Grids}
\label{sec:pn_staggered}

In figure~\ref{fig:pn_staggered_grid_problems}\subref{fig:pn_collocated_grid_artefacts} preliminary results for the two-dimensional checkerboard problem are shown, a popular reference problem for deterministic methods (section~\ref{sec:pn_results}). As seen in the figure, it suffers from servere artefacts, which exhibit an oscillating structure. The cause for these artefacts is a known problem for partial differential equations, which have different quantities influencing each other at the same spatial grid locations. The problem is visualized in figure~\ref{fig:pn_staggered_grid_problems}\subref{fig:pn_staggered_grid_idea}, using a simple one-dimensional grid as an example. Shown is a simple problem with two variables, which are located at the same grid points, referred to as collocated grids. The variable $\beta$ depends on the derivative of $\alpha$. Due to central difference discretization, two different solutions that are decoupled from each other can emerge. These solutions are interleaved in an oscillating pattern throughout the grid as shown in the upper part of the figure.

\begin{figure}[h]
\centering
\begin{subfigure}[t]{0.49\columnwidth}
\centering
\includegraphics[width=\columnwidth]{04_pn_method/results/checkerboard2d_p1_collocated.png}
%\missingfigure{2d collocated solution with artefacts}
\caption{$P_1$-solution of the checkerboard problem using collocated discretization grid.}
\label{fig:pn_collocated_grid_artefacts}
\end{subfigure}%
\hspace{0.01\columnwidth}
\begin{subfigure}[t]{0.49\columnwidth}
\centering
\includegraphics[width=\columnwidth]{04_pn_method/figures/fig_staggered_grid_1d_example.pdf}
%\missingfigure{1d schematic view of staggered grid idea, showing the problem with collocated grids}
\caption{Example showing the problem with finite differences producing a false solution (top) and its treatmen with staggering (bottom).}
\label{fig:pn_staggered_grid_idea}
\end{subfigure}%
%\vspace{-0.2in}
\caption{Artefacts in the solution (left) due to shortcomings of collocated grid locations. These are addressed using staggered grids (exemplified right).}
\label{fig:pn_staggered_grid_problems}
\end{figure}

The solution to this problem is to offset the coefficients $\alpha$ and $\beta$ from each other spatially. This configuration is called staggered grids. As visualized in figure~\ref{fig:pn_staggered_grid_problems}\subref{fig:pn_staggered_grid_idea} bottom, setting up the coefficients in that way prevents decoupling and results in a single coherent solution throughout the grid. A similar staggering of the interdependent variables is required for the $P_N$-solver to produce correct results.

The staggered grid locations are found by subdividing the original grid into a finer grid of double resolution. The locations are at the grid points of that finer grid. In terms of the original grid, these are located at the voxel centers, the center of the voxel faces between adjacent voxels, the center of voxel edges and at voxel corners as shown in figure~\ref{fig:staggered_grid}.
\begin{figure}[h]
\centering
\includegraphics[width=0.65\textwidth]{04_pn_method/figures/fig_staggered_grid.pdf}
\caption{Staggered grid configuration in 2d. Extending the concept to 3d is straightforward.}
\label{fig:staggered_grid}
\end{figure}

With a staggered grid configuration, the question is which unknowns (the spherical harmonics coefficients) are placed at which staggered grid location. Seibold et al.~\cite{Seibold14} analysed the structure of the transport term and found that its discretization matrix relates coefficients to their derivatives in a very particular structure after converting the matrix to real-valued spherical harmonics. If coefficients are located on the staggered grid according to this structure, no interpolation is required, when evaluating coefficients for central differences (see figure~\ref{fig:staggered_grid_placement}).

Assuming this structure, the unknown locations are found by the following algorithm: First the zero coefficient is placed at the voxel center. Then all coefficients are found, which depend on derivatives of the zero coefficient. These coefficients are placed according to the central difference offsets. Followingly, the coefficients are found, which depend on derivatives of the recently placed coefficients. The central difference offsets are used anew to find their new location. The particular structure of discretization matrix of the transport term in the real-valued $P_N$-equations is what allows placing the coefficients without any conflicts. 
\begin{figure}[h]
\centering
\includegraphics[width=0.95\textwidth]{04_pn_method/figures/fig_staggered_grid_finding_locations.pdf}
\caption{The process of finding staggered grid locations for unknowns $\phi_i$. The $P_N$-equations relate the unknowns through spatial derivatives, which imply an order on the finite difference grid. The first unknown is placed at the voxel center and the remaining unknown locations are found by following the spatial derivatives through the equations.}
\label{fig:staggered_grid_placement}
\end{figure}

It is important to realize that each equation in the system of linear equations relates a particular coefficient with spherical harmonics indices $l,m$ in a particular voxel within the finite difference grid to other coefficients at the same or adjacent voxels (due to derivatives). Therefore, the equation associated with a particular spherical harmonics index $l,m$ within the $P_N$-equations, is implicitly defined at the location of the spherical harmonics coefficient with the same $l,m$ index. Due to staggering, the equations are consequently defined at different locations. This has a paramount consequence for the spatial discretization step during stencil code generation.

In section~\ref{sec:pn_stencil_gen} the spatial discretization was carried out as a manipulation on the expression tree representing the $P_N$-equations. This manipulation step traversed the tree and replaced the continuous spatial variable $\vec{x}$ by its discrete counterpart $x_{ijk}$. During traversal a stack was used to keep track of the current location which would change due to shifts from central difference discretizations of differential operators within the expression tree. This stack was initialized with the reference position $x_{ijk}$ which would refer to the voxel center. This was correct, as all coefficients and equations were collocated at this position. With staggered grids, the equations are to be evaluated at the grid location implied by the position of the respective spherical harmonics coefficient with index $l,m$. Therefore, to account for staggered grids, the position stack needs to be initialized with the staggered grid location of the $l,m$-equation, which is being discretized.

The discretization step will replace the evaluation of a coefficient at a particular location, with an interpolation of that coefficient from the surrounding grid locations at which it is defined (figure~\ref{fig:pn_discretization_interpolation}). This approach will handle the staggering naturally.

Staggering spherical harmonics coefficients also makes handling boundary conditions more involved. With collocated grids it is straightforward to identify boundary voxels and voxels in the computational domain. Each voxel in the computational domain contributes the same number of unknowns to the system. With staggered grids some boundary voxels will have a subset of their unknowns that lie directly on the boundary. Without changes to the system, this will imply a shifted boundary interface and introduce an asymmetry. Coefficients, which are located on the boundary, will be unknowns and part of the solution vector on one side and subject to boundary conditions on the other side (figure~\ref{fig:pn_staggered_grid_unhandled_bc}~\subref{fig:pn_staggering_asymmetry_bc}). This creates different boundary conditions on opposite sides of the problem domain and causes an asymmetry in the solution for symmetric problems (figure~\ref{fig:pn_staggered_grid_unhandled_bc}~\subref{fig:pn_staggering_asymmetry_bc_checkerboard}).
\begin{figure}[h]
\centering
\begin{subfigure}[t]{0.49\columnwidth}
\centering
\includegraphics[width=1\textwidth]{04_pn_method/figures/fig_staggered_grid_domain_boundary_wrong.pdf}
\caption{Per voxel staggered grid locations.}
\label{fig:pn_staggering_asymmetry_bc}
\end{subfigure}%
\hspace{0.01\columnwidth}
\begin{subfigure}[t]{0.49\columnwidth}
\centering
\includegraphics[width=0.66\columnwidth]{04_pn_method/results/p1_staggered_grid_asymmetric_bc.png}
%\missingfigure{checkerboard result for unhandled BC the asymmetry}
\caption{$P_1$-solution.}
\label{fig:pn_staggering_asymmetry_bc_checkerboard}
\end{subfigure}%
%\vspace{-0.2in}
\caption{Dealing with staggered grid locations per voxel (left) implies a boundary interface which produces asymmetric results as seen for the solution of the checkerboard problem (right).}
\label{fig:pn_staggered_grid_unhandled_bc}
\end{figure}

The solution is to introduce additional unknowns to the system for every coefficient which is located on the boundary in a boundary voxel as shown in figure~\ref{fig:pn_staggered_grid_handled_bc}\subref{fig:pn_staggering_correct_bc}. This will correct the location of the boundary interface and allows the same boundary conditions on opposite sides of the computational domain.
\begin{figure}[h]
\centering
\begin{subfigure}[t]{0.49\columnwidth}
\centering
\includegraphics[width=1\textwidth]{04_pn_method/figures/fig_staggered_grid_domain_boundary_corrected.pdf}
\caption{Adjusted placement of staggered grid coefficients.}
\label{fig:pn_staggering_correct_bc}
\end{subfigure}%
\hspace{0.01\columnwidth}
\begin{subfigure}[t]{0.34\columnwidth}
\centering
\includegraphics[width=\columnwidth]{04_pn_method/results/checkerboard2d_p5_neumann_staggered.png}
%\missingfigure{checkerboard result for unhandled BC the asymmetry}
\caption{$P_1$-solution of the checkerboard problem.}
\label{fig:pn_staggering_correct_bc_checkerboard}
\end{subfigure}%
%\vspace{-0.2in}
\caption{Placing staggered grid coefficients such that the defined boundary interface is symmetric (left) leads to a correct symmetric solution of the checkerboard problem (right).}
\label{fig:pn_staggered_grid_handled_bc}
\end{figure}

The handling of boundary conditions is done by the solver framework. In order to support staggered grids, the stencil code will be generated with an additional function, which specifies the grid location of each coefficient. This function is used by the \emph{VoxelManager} to work out which additional unknowns are required.This results in a complex management of indices of unknowns, as a simple indexing function is not sufficient anymore. Transparently handling this complexity is the purpose of the \emph{VoxelManager} class.

For client code applications, it is desirable to have all coefficients defined at the centers of voxels covering the problem domain. Therefore the solver framework offers a \emph{unstagger} function for staggered grids, which interpolates all coefficients at the voxel centers of the problem domain from the surrounding coefficient locations. Further the additional unknowns, which have been introduced to get correct boundary conditions, will be removed. This function converts a staggered grid solution vector to a collocated grid solution vector.

As shown in figure~\ref{fig:pn_staggering_correct_bc_checkerboard}, using the collocated grid from converting a staggered grid solution of a staggered grid solve, will produce a result free of oscillation and asymmetry artefacts.

\subsection{System Matrix and Solution}
\label{sec:pn_system_matrix}

After initializing the \emph{PNSystemBuilder} object matrix with the \emph{Stencil} and \emph{Scene}, the system matrix $A$ and right hand side vector $\vec{b}$ are built and made available to the client code, which will use it to solve for the solution vector $\vec{u}$. The solver developed as part of this thesis uses Eigen~\cite{Eigen}, but any other linear algebra package with standard methods available is applicable too. 

However, the system matrix $A$, when generated from the $P_N$-equations, has properties which restrict application of certain methods for solving the system. The number of rows and columns of $A$ is determined by the total number of voxels in the computational domain, multiplied by the number of spherical harmonics coefficients per voxel. The matrix is squared and sparse due to the local structure of the discretization and coupling. Unfortunately, the system matrix $A$ is non-symmetric (due to the transport term) and not diagonal dominant, which together rules out many iterative methods for solving linear systems.
\begin{figure}[h]
\centering
%\missingfigure{structure of the system matrix and solution vector (the figure from the paper)}
\includegraphics[width=0.75\textwidth]{04_pn_method/figures/fig_matrix_layout.pdf}
\caption{Structure of coefficient matrix $A$ and solution vector $\vec{u}$ after discretization of the $P_N$-equations on a finite difference grid.}
\label{fig:pn_matrix_layout}
\end{figure}

Some standard methods, such as LU-decomposition, QR-decomposition or Singular-value decomposition allow solving systems of linear equations with non-symmetric coefficient matrices $A$ and are applicable to solving the system generated by the $P_N$-solver. 

Due to the asymmetry in $A$, iterative methods can not be applied directly. However, iterative methods can be applied by solving the normal form
\begin{align}
A^TA\vec{u} = A^T\vec{b}
\end{align}
instead. This gives a symmetric and positive definit system matrix $A^TA$, albeit with a higher condition number. Investigation of other solution schemes (e.g. multigrid) would be an interesting avenue for future work.

However, more importantly, in the presence of vacuum regions, matrix $A$ becomes singular and the system cannot be solved at all. The intuition behind this behaviour is that in case of vacuum, the collision and scattering terms vanish completely, leaving the transport operator to exclusively define the solution. Since the transport operator only defines the relationship between unknowns in terms of their derivatives, it becomes clear that this is not enough information to constitute a unique solution. This is best exemplified by looking at a minimal version of that problem:
\begin{align*}
\frac{df\left(x\right)}{dx} = b\left(x\right)
\end{align*}
This differential equation imposes a constraint on the derivative of the solution. A function, which satisfies this constraint would still satisfy it, when a constant is added to the solution. Therefore, there is no unique solution to this problem and hence the matrix $A$ after discretization will be singular.

A solution to this problem is to specify additional boundary conditions. However, for problems of simple complexity, this would already amount to finding a solution to the problem in the first place.

A simple alternative to which this thesis referres back is minimum thresholding. A minimum threshold value $\sigma_{min}$ is specified by the user. That threshold value is returned for any extinction value that falls below that threshold. This amounts to adding an ambient extinction medium by which vacuum regions are avoided completely and which causes the system to never become singular. Let $\sigma_{ot}$ be the original extinction coefficient coming from the input dataset. Unless stated otherwise, throughout this thesis the extinction coefficient is defined to be
\begin{align}
\label{eq:pn_solver_minimum_threshold}
\sigma_t\left(\vec{x}\right) =
\begin{cases}
\sigma_{ot}\left(\vec{x}\right), & \text{for $\sigma_{ot}\ge\sigma_{min}$}
\\
\sigma_{min}, & \text{otherwise}
\end{cases}
\end{align}

This concludes the section on the $P_N$-solver and its system components.